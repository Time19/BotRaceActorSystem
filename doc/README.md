# Documentation (yet a Template)

> **Disclaimer:** This documentation might have been enhanced and grammar checked with chatGPT and deepl.

## Introduction

The Bot-Race Actor system is a distributed system that simulates a race between bots on a board. The role of the board
is to provide the game environment, including obstacles and the target that the bots must navigate to. The bots have
limited information about the board and communicate with the board to get information about available directions and the
chosen direction.

An example of a board layout could be a rectangular grid with obstacles represented by walls or barriers. The starting
point for the bots could be at one end of the grid, and the target could be at the other end. The bots must navigate
through the grid, avoiding obstacles and reaching the target.

\
The phases of the board when playing the game are:

- **Setup Phase:**\
The board is set up with the initial configuration, including the layout of obstacles and the starting
and target positions.

- **Playing Phase:**\
The bots start the race, and they communicate with the board to get information about available
directions and the chosen direction. They move one step at a time, and the board updates their positions accordingly.

- **Pause Phase:**\
The board can pause the race at any time, for example, if a bot reaches a specific position or if a
certain condition is met.

- **Resume Phase:**\
The race can be resumed after being paused, allowing the bots to continue their movement.

- **Termination Phase:** \
The race is terminated when all bots have reached the target or when a specific condition is met,
such as a certain time limit or a specific number of steps taken.

**Akka**\
The basic principle of Akka is to build distributed systems using actors, which are lightweight, isolated, and
independent units of execution. Akka provides a message-passing model where actors communicate with each other by
sending messages. Actors are resilient to failures and can be scaled horizontally by adding more actors. The Bot-Race
Actor system utilizes Akka to implement the distributed behavior of the bots and the board.

## Document the Bot / Board Interaction

### Interaction between a Bot and the Board

In the happy case, the bot registers with the board, receives the setup information, and then requests available
directions to move. The board responds with the available directions, and the bot moves to a new position. This process
continues until the bot reaches the target, at which point the board sends a termination message to the bot.

#### Error Cases

- **Unknown Message:** If the bot sends an unknown message to the board, the board will respond with an error message, and
the
bot will not be able to continue playing.

- **Timeout:** If the bot does not respond to the board's messages within a certain time limit, the board will assume that
the
bot has timed out and will terminate the game.

### Sequencediagram without interrupts

![Sequencediagram](../img/Sequencediagram_without.svg)

### Sequencediagram wih interrupts

![Sequencediagram](../img/Sequencediagram_with.svg)

## The Design of the Board Actor System

### Classdiagram *(Generated by IntelliJ IDEA)*

![Classdiagram](src/classdiagram.png)

### States of the Board Actor System

The board actor system has the following states:

- `Setup`: The state when the board is being set up. The board is configured and the obstacles and target positions
  are set. The board is not yet ready to receive messages from the bots.

- `Register`: The state when the board is ready to receive messages from the bots. The board is listening for register
  messages from the bots.

- `Play`: The state when the race is ongoing. The board is receiving messages from the bots and updating their
  positions accordingly.

- `Pause`: The state when the race is paused. The board is not receiving messages from the bots and is not updating
  their positions. The race can be resumed at any time.

## The Design of the Bot Actor System

The bot actor system is designed to handle the behavior of the bots in the Bot-Race actor system. It consists of several
actors, each representing a bot.

### Classes in the Bot Actor System

- `BotRoot`: Represents the root actor of the bot actor system.
- `ClusterListener`: Listens to cluster events and handles the registration and deregistration of bots.
- `Bot`: Represents a single bot in the system.

### States of the Bot Actor System

The bot actor system has the following states:

- `PhaseStarting`: The state when the bot is initializing and preparing to register with the board actor system.

- `PhaseRegister`: The state when the bot is registering with the board actor system. The bot is waiting for the board to
  respond with a setup message.

- `PhaseReady`: The state when the bot is ready to start the race. The bot is waiting for the board to start the race.

- `PhasePlaying`: The state when the bot is playing the race. The bot is sending messages to the board to request
  available directions and move to a new position.

- `TargetReached`: The state when the bot has reached the target position. The bot is waiting for the board to terminate
  the race.

### Termination of the Bot Actor System

The bot actor system terminates when all the bot actors have terminated. This can happen for several reasons:

- All the bots have reached the target position.
- All the bots have been deregistered.
- The board actor system has terminated.

When the bot actor system terminates, it sends a message to the board actor system to inform it of the termination.

## The Algorithms of the Bots

The bot uses a randomized path selection algorithm to navigate a grid and reach a target position. At each move, it
queries the possible directions it can go from the current position and randomly picks one direction from this set. The
botâ€™s path selection logic is straightforward but not optimal, as it lacks memory of past positions or awareness of
dead-ends, which makes it susceptible to revisiting the same points repeatedly or getting stuck in loops.

Here's an example of a pseudocode for the bot's algorithm:

```pseudocode
function playGame() {
    initializeBot();
    while (true) {
        switch (currentPhase) {
            case REGISTERING:
                registerWithBoard();
                waitForGameToStart();
                break;

            case READY:
                waitForAvailableDirections();
                break;

            case PLAYING:
                chooseDirection();
                sendChosenDirectionToBoard();
                checkIfMoveIgnored();
                checkIfTargetReached();
                break;

            case PAUSED:
                waitForResumeMessageFromBoard();
                break;

            case TARGET_REACHED:
                deregisterWithBoard();
                return;  // Spiel endet, wenn das Ziel erreicht ist
        }
    }
}

// Phase: REGISTERING
function registerWithBoard() {
    // Send registration message to the board
    print("Registering bot with the board");
}

function waitForGameToStart() {
    // Wait until the start message is received
    print("Waiting for game to start...");
}

// Phase: READY
function waitForAvailableDirections() {
    // Request available directions from the board and wait for response
    print("Requesting available directions from the board");
}

// Phase: PLAYING
function chooseDirection() {
    availableDirections = getAvailableDirections();  // Retrieve from board message
    if (availableDirections.isEmpty()) {
        print("No directions available");
        return;
    }
    
    // **Simple Strategy for Pathfinding**:
    // 1. Evaluate each direction:
    //    - If moving closer to the target, prioritize it.
    //    - If not closer, deprioritize.
    // 2. Choose the first best direction; fallback to random if blocked.
    
    bestDirection = null;
    minDistanceToTarget = calculateDistanceToTarget(currentPosition);
    
    // Evaluate all directions to find the best one
    for each direction in availableDirections {
        newPosition = calculateNewPosition(currentPosition, direction);
        distanceToTarget = calculateDistanceToTarget(newPosition);
        
        if (distanceToTarget < minDistanceToTarget) {
            minDistanceToTarget = distanceToTarget;
            bestDirection = direction;
        }
    }

    // If a closer direction is found, choose it; otherwise, pick a random direction
    chosenDirection = bestDirection != null ? bestDirection : chooseRandomDirection(availableDirections);
}

function sendChosenDirectionToBoard() {
    // Send the chosen direction to the board
    print("Sending chosen direction to board:", chosenDirection);
}

function checkIfMoveIgnored() {
    // If the move is ignored, request available directions again
    if (moveWasIgnored()) {
        print("Chosen direction was ignored. Re-requesting directions");
        waitForAvailableDirections();
    }
}

function checkIfTargetReached() {
    // Check if the bot has reached the target position
    if (currentPosition == targetPosition) {
        currentPhase = TARGET_REACHED;
        print("Target reached!");
    }
}

// Phase: PAUSED
function waitForResumeMessageFromBoard() {
    // Wait for a resume message to continue playing
    print("Game paused. Waiting to resume...");
}

// Phase: TARGET_REACHED
function deregisterWithBoard() {
    // Send deregistration message to the board
    print("Deregistering bot from the board");
}

// **Helper Functions**:
function calculateNewPosition(currentPosition, direction) {
    // Calculate new position based on direction
    return newPosition;
}

function calculateDistanceToTarget(position) {
    // Calculate distance from the given position to the target
    return distance;
}

function chooseRandomDirection(availableDirections) {
    // Choose a random direction from available options
    return randomDirection;
}

function moveWasIgnored() {
    // Check if the move was ignored based on board response
    return trueOrFalse;
}

function initializeBot() {
    // Set initial values for bot
    currentPhase = REGISTERING;
    currentPosition = (0, 0);
    moveCount = 0;
    recentDirections = [];
}
```

This is a simplified example, and the actual implementation may vary based on the specific requirements and design
decisions of your bot.

## Administrative Issues

**Gil**\
This project allowed me to enhance my understanding of distributed systems, specifically with Akka's actor-based
approach. I was involved in designing the board actor system, focusing on message handling between the bots and the
board. This project highlighted the importance of effective communication between team members, as well as a deep
understanding of concurrent programming concepts. I found it challenging yet rewarding to design the message protocols
and ensure consistent state transitions in the system.

**Martin**\
Working on the bot race game gave me the opportunity to develop my skills in pathfinding and algorithm design. I worked
closely on the botâ€™s movement logic, implementing strategies to detect and avoid dead-ends, which involved understanding
how to track previously visited positions and apply memory-based movement to optimize navigation. This experience
improved my problem-solving abilities, especially in debugging movement paths and refining the botâ€™s efficiency within
the grid.

**Pablo**\
In this project, I was able to apply and expand my knowledge of distributed systems using the Akka framework. My role
primarily focused on error handling and optimizing the boardâ€™s response times to bot requests. Working on exception
management and error-case scenarios taught me a lot about resilience in distributed applications, which are critical
when multiple actors interact. Additionally, I took part in debugging the actor interactions, which strengthened my
understanding of concurrency and synchronization in Java.

**Tim**\
Using Git and GitHub for version control was a new and valuable experience for me. I learned to manage branches, submit
pull requests, and resolve merge conflicts, which improved my workflow. I also took on part of the GUI design for this
project, which presented a unique challenge. Some troubles appeared as I tried to use the FXMLLoader. However, this experience
taught me a lot about UI design principles and integration with backend systems.

### Contributor analytics

![contributor-analytics](src/Contributor_Analytics.png)
